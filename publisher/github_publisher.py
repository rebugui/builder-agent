"""
GitHub Publisher - GitHub ì €ì¥ì†Œ ìƒì„± ë° ì½”ë“œ í‘¸ì‹œ
"""
import os
import base64
from typing import Dict, Any, Optional, List
from datetime import datetime
import requests

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from models.idea import ProjectIdea, DevelopmentResult, PublishedProject


class GitHubPublisher:
    """GitHub ì €ì¥ì†Œ í¼ë¸”ë¦¬ì…”"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.github_token = os.getenv("GITHUB_TOKEN")
        self.github_username = os.getenv("GITHUB_USERNAME", "rebugui")
        self.api_base = "https://api.github.com"
        self.headers = {
            "Authorization": f"token {self.github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
    
    def publish(self, result: DevelopmentResult) -> PublishedProject:
        """
        GitHubì— í”„ë¡œì íŠ¸ ê²Œì‹œ
        
        Args:
            result: ê°œë°œ ê²°ê³¼
            
        Returns:
            PublishedProject: ê²Œì‹œëœ í”„ë¡œì íŠ¸ ì •ë³´
        """
        if not result.success:
            raise Exception(f"Cannot publish failed development: {result.error}")
        
        if not self.github_token:
            raise Exception("GITHUB_TOKEN not configured")
        
        # 1. ì €ì¥ì†Œ ìƒì„±
        repo_info = self._create_repository(result.idea)
        
        # 2. íŒŒì¼ ì—…ë¡œë“œ
        for filename, content in result.files.items():
            self._upload_file(repo_info["name"], filename, content)
        
        # 3. README ìƒì„±
        readme_content = self._generate_readme(result.idea, result)
        self._upload_file(repo_info["name"], "README.md", readme_content)
        
        # 4. requirements.txt ìƒì„±
        requirements = self._generate_requirements(result)
        if requirements:
            self._upload_file(repo_info["name"], "requirements.txt", requirements)
        
        # 5. .gitignore ìƒì„±
        gitignore = self._generate_gitignore(result.idea.project_type.value)
        self._upload_file(repo_info["name"], ".gitignore", gitignore)
        
        # 6. GitHub Actions CI ì„¤ì •
        if self.config.get("enable_ci", True):
            ci_config = self._generate_ci_config(result.idea)
            self._upload_file(repo_info["name"], ".github/workflows/ci.yml", ci_config)
        
        # 7. ê²°ê³¼ ë°˜í™˜
        return PublishedProject(
            idea=result.idea,
            github_url=repo_info["html_url"],
            repository_name=repo_info["full_name"],
            created_at=datetime.now(),
            last_updated=datetime.now()
        )
    
    def _create_repository(self, idea: ProjectIdea) -> Dict[str, Any]:
        """GitHub ì €ì¥ì†Œ ìƒì„±"""
        url = f"{self.api_base}/user/repos"
        
        data = {
            "name": idea.name,
            "description": idea.description,
            "private": False,
            "has_issues": True,
            "has_projects": False,
            "has_wiki": False,
            "auto_init": False
        }
        
        response = requests.post(url, json=data, headers=self.headers)
        
        if response.status_code == 422:
            # ì €ì¥ì†Œê°€ ì´ë¯¸ ì¡´ì¬í•¨
            raise Exception(f"Repository {idea.name} already exists")
        elif response.status_code != 201:
            raise Exception(f"Failed to create repository: {response.text}")
        
        return response.json()
    
    def _upload_file(self, repo_name: str, filename: str, content: str, message: str = None):
        """íŒŒì¼ ì—…ë¡œë“œ"""
        url = f"{self.api_base}/repos/{self.github_username}/{repo_name}/contents/{filename}"
        
        # Base64 ì¸ì½”ë”©
        content_bytes = content.encode('utf-8')
        content_base64 = base64.b64encode(content_bytes).decode('utf-8')
        
        data = {
            "message": message or f"Add {filename}",
            "content": content_base64
        }
        
        response = requests.put(url, json=data, headers=self.headers)
        
        if response.status_code not in [200, 201]:
            print(f"[WARN] Failed to upload {filename}: {response.text}")
    
    def _generate_readme(self, idea: ProjectIdea, result: DevelopmentResult) -> str:
        """README.md ìƒì„±"""
        readme = f"""# {idea.name}

{idea.description}

## Overview

This project was automatically generated by **Builder Agent v3** powered by ChatDev 2.0 and GLM-5.

- **Source**: {idea.source.value}
- **Type**: {idea.project_type.value}
- **Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Features

"""
        # ìš”êµ¬ì‚¬í•­ì„ ê¸°ëŠ¥ìœ¼ë¡œ ë³€í™˜
        for req in idea.requirements:
            readme += f"- {req}\n"
        
        readme += f"""

## Installation

```bash
# Clone the repository
git clone https://github.com/{self.github_username}/{idea.name}.git
cd {idea.name}

# Install dependencies
pip install -r requirements.txt
```

## Usage

```bash
python -m {idea.name.replace('-', '_')} --help
```

## Development

This project was developed using ChatDev 2.0 multi-agent collaboration:

1. **CEO** - Requirements analysis and project planning
2. **CTO** - Technical architecture design
3. **Programmer** - Code implementation
4. **Reviewer** - Code quality review
5. **Tester** - Unit test generation
6. **CTO Final** - Final verification

## Technical Stack

"""
        for tech in idea.technical_stack:
            readme += f"- {tech}\n"
        
        readme += f"""

## License

MIT License

## Generated by

ğŸ¤– **Builder Agent v3** - Automated software development with AI

- ChatDev 2.0: Multi-agent collaboration framework
- GLM-5: Advanced AI model for code generation

"""
        
        return readme
    
    def _generate_requirements(self, result: DevelopmentResult) -> str:
        """requirements.txt ìƒì„±"""
        # ê¸°ë³¸ ì˜ì¡´ì„±
        requirements = {
            "click": ">=8.0.0",
            "rich": ">=13.0.0",
            "pydantic": ">=2.0.0",
            "pytest": ">=7.0.0",
            "pytest-cov": ">=4.0.0"
        }
        
        # í”„ë¡œì íŠ¸ íƒ€ì…ë³„ ì¶”ê°€ ì˜ì¡´ì„±
        project_type = result.idea.project_type.value
        
        if project_type == "security_tool":
            requirements["requests"] = ">=2.28.0"
            requirements["beautifulsoup4"] = ">=4.11.0"
        
        elif project_type == "data_analysis":
            requirements["pandas"] = ">=2.0.0"
            requirements["matplotlib"] = ">=3.5.0"
        
        elif project_type == "api_service":
            requirements["fastapi"] = ">=0.100.0"
            requirements["uvicorn"] = ">=0.20.0"
        
        # í¬ë§·íŒ…
        lines = []
        for pkg, version in sorted(requirements.items()):
            lines.append(f"{pkg}{version}")
        
        return "\n".join(lines)
    
    def _generate_gitignore(self, project_type: str) -> str:
        """ .gitignore ìƒì„±"""
        common = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
env/
ENV/
.venv

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Testing
.pytest_cache/
.coverage
htmlcov/

# Logs
*.log
logs/
"""
        
        # í”„ë¡œì íŠ¸ íƒ€ì…ë³„ ì¶”ê°€ í•­ëª©
        if project_type == "data_analysis":
            common += "\n# Data\n*.csv\n*.xlsx\n*.json\n!sample.json\n"
        
        return common
    
    def _generate_ci_config(self, idea: ProjectIdea) -> str:
        """GitHub Actions CI ì„¤ì • ìƒì„±"""
        ci_config = f"""name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11']

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{{{ matrix.python-version }}}}
      uses: actions/setup-python@v4
      with:
        python-version: ${{{{ matrix.python-version }}}}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov
    
    - name: Run tests
      run: |
        pytest tests/ -v --cov={idea.name.replace('-', '_')} --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
"""
        
        return ci_config
    
    def get_repository_stats(self, repo_name: str) -> Dict[str, Any]:
        """ì €ì¥ì†Œ í†µê³„ ì¡°íšŒ"""
        url = f"{self.api_base}/repos/{self.github_username}/{repo_name}"
        
        response = requests.get(url, headers=self.headers)
        
        if response.status_code == 200:
            data = response.json()
            return {
                "stars": data.get("stargazers_count", 0),
                "forks": data.get("forks_count", 0),
                "watchers": data.get("watchers_count", 0),
                "open_issues": data.get("open_issues_count", 0),
                "last_updated": data.get("updated_at")
            }
        
        return {}


if __name__ == "__main__":
    # í…ŒìŠ¤íŠ¸
    from ..models.idea import ProjectIdea, IdeaSource, ProjectType, Priority
    
    publisher = GitHubPublisher()
    
    if not publisher.github_token:
        print("âŒ GITHUB_TOKEN not set")
        print("   export GITHUB_TOKEN=your_token_here")
    else:
        print("âœ… GITHUB_TOKEN configured")
        print(f"   Username: {publisher.github_username}")
